import json
import logging
import os
from json import dumps, loads

import yaml
from django.apps import apps
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from django_swagger_tester.schema_validation.request_body.utils import get_request_body
from django_swagger_tester.schema_validation.response.utils import get_response_schema
from django_swagger_tester.utils import get_paths, resolve_path, validate_inputs

logger = logging.getLogger('django_swagger_tester')


class LoadSchemaBase:
    """
    Base class for OpenAPI schema loading classes.

    The base contains a template of methods that are required from a loader class.
    """

    def validation(self, *args, **kwargs) -> None:
        """
        This method should hold class level validation logic to be called in the parent class' init method.

        For example, useful validation could include checking for schema-type specific dependencies and configurations.
        """
        pass

    def get_schema(self, *args, **kwargs) -> None:
        """
        Returns the OpenAPI schema as a dict.
        """
        raise ImproperlyConfigured('The `get_schema` method has to be overwritten.')

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> None:
        """
        Returns the response section of a schema, filtered down by method, status code, and path.
        """
        raise ImproperlyConfigured('The `get_response_schema` method has to be overwritten.')

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> None:
        """
        Returns the request body section of a schema, filtered down by method, and path.
        """
        raise ImproperlyConfigured('The `get_request_body` method has to be overwritten.')


class LoadDrfYasgSchema(LoadSchemaBase):
    """
    Loads OpenAPI schema when schema is dynamically generated by drf_yasg.
    """

    def __init__(self, **kwargs) -> None:
        self.validation()
        from drf_yasg.openapi import Info
        from drf_yasg.generators import OpenAPISchemaGenerator

        self.schema_generator = OpenAPISchemaGenerator(info=Info(title='', default_version=''))

    def validation(self) -> None:
        """
        For drf_yasg-generated schemas, it's important that we verify:
        1. The package is installed
        2. drf_yasg is in the projects installed_apps
        """
        try:
            import drf_yasg  # noqa: F401
        except ModuleNotFoundError:
            raise ImproperlyConfigured(
                'The package `drf_yasg` is required. Please run `pip install drf_yasg` to install it.'
            )
        if 'drf_yasg' not in apps.app_configs.keys():
            raise ImproperlyConfigured(
                'The package `drf_yasg` is missing from INSTALLED_APPS. Please add it to your '
                '`settings.py`, as it is required for this implementation'
            )

    def get_schema(self) -> dict:
        """
        Fethes a generated schema from drf-yasg and returns it as a dict.
        """
        odict_schema = self.schema_generator.get_schema(None, True)
        return loads(dumps(odict_schema.as_odict()))

    def get_path_prefix(self) -> str:
        """
        Returns the drf_yasg specified path prefix.

        Drf_yasg `cleans` schema paths by finding recurring path patterns,
        and cutting them out of the generated openapi schema.
        For example, `/api/v1/example` might then just become `/example`
        """
        return self.schema_generator.determine_path_prefix(get_paths())

    def get_drf_yasg_compatible_route(self, route: str) -> str:
        """
        Returns a url that matches the urls found in a drf_yasg-generated schema.

        :param route: Django resolved route
        """
        resolved_route = resolve_path(route)
        path_prefix = self.get_path_prefix()  # typically might be 'api/' or 'api/v1/'
        logger.debug('Path prefix: %s', path_prefix)
        if path_prefix != '/':
            return resolved_route[len(path_prefix) :]
        else:
            return resolved_route

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code
        to get the section of a schema related to a specific response.
        """
        validate_inputs(route=route, status_code=status_code, method=method)
        schema = self.get_schema()
        resolved_route = self.get_drf_yasg_compatible_route(route)
        return get_response_schema(schema=schema, method=method, status_code=status_code, route=resolved_route)

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code,
        to get the request body of the section of a schema related to an endpoint.
        """
        validate_inputs(route=route, status_code=None, method=method)
        schema = self.get_schema()
        resolved_route = self.get_drf_yasg_compatible_route(route)
        return get_request_body(schema=schema, method=method, route=resolved_route)


class LoadStaticSchema(LoadSchemaBase):
    """
    Loads OpenAPI schema from a static file.
    """

    def __init__(self, **kwargs) -> None:
        package_settings = settings.SWAGGER_TESTER
        self.validation(package_settings)
        self.path = package_settings['PATH']

    def validation(self, package_settings: dict) -> None:
        """
        Before trying to load static schema, we need to verify that:
        - The path to the static file is provided, and that the file type is compatible (json/yml/yaml)
        - The right parsing library is installed (pyYAML for yaml, json is builtin)
        """
        if 'PATH' not in package_settings or package_settings['PATH'] is None:
            logger.error('PATH setting is not specified.')
            raise ImproperlyConfigured(
                f'`PATH` is required when testing static schemas. Please update your SWAGGER_TESTER settings.'
            )
        elif not isinstance(package_settings['PATH'], str):
            logger.error('PATH setting is not a string.')
            raise ImproperlyConfigured('`PATH` needs to be a string. Please update your SWAGGER_TESTER settings.')
        if '.yml' in package_settings['PATH'] or '.yaml' in package_settings['PATH']:
            try:
                import yaml  # noqa: F401
            except ModuleNotFoundError:
                raise ImproperlyConfigured(
                    'The package `PyYAML` is required for parsing yaml files. '
                    'Please run `pip install PyYAML` to install it.'
                )

    def get_schema(self) -> dict:
        """
        Loads a static OpenAPI schema from file, and parses it to a python dict.

        :return: Schema contents as a dict
        :raises: ImproperlyConfigured
        """
        if not os.path.isfile(self.path):
            logger.error('Path `%s` does not resolve as a valid file.', self.path)
            raise ImproperlyConfigured(
                f'The path `{self.path}` does not point to a valid file. Make sure to point to the specification file.'
            )
        try:
            logger.debug('Fetching static schema from %s', self.path)
            with open(self.path, 'r') as f:
                content = f.read()
        except Exception as e:
            logger.exception('Exception raised when fetching OpenAPI schema from %s. Error: %s', self.path, e)
            raise ImproperlyConfigured(
                f'Unable to read the schema file. Please make sure the path setting is correct.\n\nError: {e}'
            )
        if '.json' in self.path:
            return json.loads(content)
        elif '.yaml' in self.path or '.yml' in self.path:
            return yaml.load(content, Loader=yaml.FullLoader)
        else:
            raise ImproperlyConfigured('The specified file path does not seem to point to a JSON or YAML file.')

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code to get the section of a schema related to a specific response.
        """
        validate_inputs(route=route, status_code=status_code, method=method)
        schema = self.get_schema()
        resolved_route = resolve_path(route)
        return get_response_schema(schema=schema, method=method, status_code=status_code, route=resolved_route)

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code,
        to get the request body of the section of a schema related to an endpoint.
        """
        validate_inputs(route=route, status_code=None, method=method)
        schema = self.get_schema()
        resolved_route = resolve_path(route)
        return get_request_body(schema=schema, method=method, route=resolved_route)
