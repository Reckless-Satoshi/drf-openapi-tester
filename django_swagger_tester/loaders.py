import json
import logging
import os
from json import dumps, loads

import yaml
from django.core.exceptions import ImproperlyConfigured

logger = logging.getLogger('django_swagger_tester')


class _LoaderBase:
    """
    Base class for OpenAPI schema loading classes.

    The base contains a template of methods that are required from a loader class.
    """

    def validation(self, *args, **kwargs) -> None:
        """
        This method should hold class level validation logic to be called in the subclass' init method.

        For example, useful validation could include checking for schema-type specific dependencies and configurations.
        """
        pass

    def get_schema(self, *args, **kwargs) -> dict:
        """
        Returns the OpenAPI schema as a dict.
        """
        raise ImproperlyConfigured('The `get_schema` method has to be overwritten.')

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> dict:
        """
        Returns the response section of a schema, filtered down by method, status code, and path.
        """
        raise ImproperlyConfigured('The `get_response_schema` method has to be overwritten.')

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> dict:
        """
        Returns the request body section of a schema, filtered down by method, and path.
        """
        raise ImproperlyConfigured('The `get_request_body` method has to be overwritten.')


class DrfYasgSchemaLoader(_LoaderBase):
    """
    Loads OpenAPI schema when schema is dynamically generated by drf_yasg.
    """

    def __init__(self, **kwargs) -> None:
        self.validation()
        from drf_yasg.openapi import Info
        from drf_yasg.generators import OpenAPISchemaGenerator

        self.schema_generator = OpenAPISchemaGenerator(info=Info(title='', default_version=''))

    def validation(self, *args, **kwargs) -> None:
        """
        For drf_yasg-generated schemas, it's important that we verify:
        1. The package is installed
        2. drf_yasg is in the projects installed_apps
        """
        try:
            import drf_yasg  # noqa: F401
        except ModuleNotFoundError:
            raise ImproperlyConfigured(
                'The package `drf_yasg` is required. Please run `pip install drf_yasg` to install it.'
            )
        from django.apps import apps

        if 'drf_yasg' not in apps.app_configs.keys():
            raise ImproperlyConfigured(
                'The package `drf_yasg` is missing from INSTALLED_APPS. Please add it to your '
                '`settings.py`, as it is required for this implementation'
            )

    def get_schema(self, *args, **kwargs) -> dict:
        """
        Fethes a generated schema from drf-yasg and returns it as a dict.
        """
        odict_schema = self.schema_generator.get_schema(None, True)
        return loads(dumps(odict_schema.as_odict()))

    def get_path_prefix(self) -> str:
        """
        Returns the drf_yasg specified path prefix.

        Drf_yasg `cleans` schema paths by finding recurring path patterns,
        and cutting them out of the generated openapi schema.
        For example, `/api/v1/example` might then just become `/example`
        """
        from django_swagger_tester.utils import get_paths

        return self.schema_generator.determine_path_prefix(get_paths())

    def get_drf_yasg_compatible_route(self, route: str) -> str:
        """
        Returns a url that matches the urls found in a drf_yasg-generated schema.

        :param route: Django resolved route
        """
        from django_swagger_tester.utils import resolve_path

        resolved_route = resolve_path(route)
        path_prefix = self.get_path_prefix()  # typically might be 'api/' or 'api/v1/'
        logger.debug('Path prefix: %s', path_prefix)
        if path_prefix != '/':
            return resolved_route[len(path_prefix) :]
        else:
            return resolved_route

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code
        to get the section of a schema related to a specific response.
        """
        from django_swagger_tester.utils import validate_inputs

        validate_inputs(route=route, status_code=status_code, method=method)

        schema = self.get_schema()
        resolved_route = self.get_drf_yasg_compatible_route(route)
        from django_swagger_tester.schema_validation.response.utils import get_response_schema

        return get_response_schema(schema=schema, method=method, status_code=status_code, route=resolved_route)

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code,
        to get the request body of the section of a schema related to an endpoint.
        """
        from django_swagger_tester.utils import validate_inputs

        validate_inputs(route=route, status_code=None, method=method)
        schema = self.get_schema()
        resolved_route = self.get_drf_yasg_compatible_route(route)
        from django_swagger_tester.schema_validation.request_body.utils import get_request_body

        return get_request_body(schema=schema, method=method, route=resolved_route)


class StaticSchemaLoader(_LoaderBase):
    """
    Loads OpenAPI schema from a static file.
    """

    def __init__(self, *args, **kwargs) -> None:
        self.path: str = ''

    def set_path(self, path: str) -> None:
        """
        Sets value for self.path
        """
        self.path = path

    def validation(self, *args, **kwargs) -> None:
        """
        Before trying to load static schema, we need to verify that:
        - The path to the static file is provided, and that the file type is compatible (json/yml/yaml)
        - The right parsing library is installed (pyYAML for yaml, json is builtin)
        """
        if (
            'package_settings' not in kwargs
            or 'PATH' not in kwargs['package_settings']
            or kwargs['package_settings']['PATH'] is None
        ):
            logger.error('PATH setting is not specified')
            raise ImproperlyConfigured(
                f'PATH is required to load static OpenAPI schemas. Please add PATH to the SWAGGER_TESTER settings.'
            )
        elif not isinstance(kwargs['package_settings']['PATH'], str):
            logger.error('PATH setting is not a string')
            raise ImproperlyConfigured('`PATH` needs to be a string. Please update your SWAGGER_TESTER settings.')
        if '.yml' in kwargs['package_settings']['PATH'] or '.yaml' in kwargs['package_settings']['PATH']:
            try:
                import yaml  # noqa: F401
            except ModuleNotFoundError:
                raise ImproperlyConfigured(
                    'The package `PyYAML` is required for parsing yaml files. '
                    'Please run `pip install PyYAML` to install it.'
                )
        self.set_path(kwargs['package_settings']['PATH'])

    def get_schema(self, *args, **kwargs) -> dict:
        """
        Loads a static OpenAPI schema from file, and parses it to a python dict.

        :return: Schema contents as a dict
        :raises: ImproperlyConfigured
        """
        if not os.path.isfile(self.path):
            logger.error('Path `%s` does not resolve as a valid file.', self.path)
            raise ImproperlyConfigured(
                f'The path `{self.path}` does not point to a valid file. Make sure to point to the specification file.'
            )
        try:
            logger.debug('Fetching static schema from %s', self.path)
            with open(self.path, 'r') as f:
                content = f.read()
        except Exception as e:
            logger.exception('Exception raised when fetching OpenAPI schema from %s. Error: %s', self.path, e)
            raise ImproperlyConfigured(
                f'Unable to read the schema file. Please make sure the path setting is correct.\n\nError: {e}'
            )
        if '.json' in self.path:
            return json.loads(content)
        elif '.yaml' in self.path or '.yml' in self.path:
            return yaml.load(content, Loader=yaml.FullLoader)
        else:
            raise ImproperlyConfigured('The specified file path does not seem to point to a JSON or YAML file.')

    def get_response_schema(self, route: str, method: str, status_code: int, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code to get the section of a schema related to a specific response.
        """
        from django_swagger_tester.utils import resolve_path, validate_inputs

        validate_inputs(route=route, status_code=status_code, method=method)
        schema = self.get_schema()
        resolved_route = resolve_path(route)
        from django_swagger_tester.schema_validation.response.utils import get_response_schema

        return get_response_schema(schema=schema, method=method, status_code=status_code, route=resolved_route)

    def get_request_body(self, route: str, method: str, *args, **kwargs) -> dict:
        """
        Indexes schema by url, HTTP method, and status code,
        to get the request body of the section of a schema related to an endpoint.
        """
        from django_swagger_tester.utils import resolve_path, validate_inputs

        validate_inputs(route=route, status_code=None, method=method)
        schema = self.get_schema()
        resolved_route = resolve_path(route)
        from django_swagger_tester.schema_validation.request_body.utils import get_request_body

        return get_request_body(schema=schema, method=method, route=resolved_route)
